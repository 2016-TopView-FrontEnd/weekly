# You don't konw JS （type & grammar）

标签（空格分隔）： JS

---

    typeof null === 'object'   //true
    
    //检测null的方式
    (!null && typeof null === 'object') === true

 
----------
### 通过typeof的安全防范机制来检查undeclared变量是个不错的选择


----------
### Array.from()
- 工具函数，可以传入类数组返回数组
- 可以用Array.prototype.slice.call()来实现相同功能


----------
### JS中数组和字符串
> JS中数组和字符串类似，但是字符串不可变，数组可变
也就是说字符串的成员函数不会改变其初始值，而是创建返回一个新的字符串，而数组是在原始值上进行操作
有时候利用call()函数去借用数组的方法来操作字符串很方便


----------
### number（数字类型）
> toFixed()方法指明保留的小数位数
toPrecision()方法指明保留的有效位数

### 错误的用法
42.toFixed(2);
### 正确的用法
42..toFixed(2);
42 .toFixed(2);


> 判断较小的数值
我们遇到过0.1 + 0.2 === 0.3; //false   这种问题
因为JS的number存在“机器精度”...这个误差值应该是“2^-52”
ES6可以用Number.EPSILON来访问这个误差值

    //polyfill
    if(!Number.EPSILON) {
        Number.EPSILON = Math.pow(2, -52);
    }


> 有些数字操作只适用32位数字（位运算），所以这些数字的安全范围会变成32位以内，可以用a | 0 将数字截取为32位的数字，因为 | 操作符只适用32位。


----------
### undefined可以被当做变量来使用和赋值，然而null却不可以被重新赋值
> 可以通过void运算符来获得undefined（因为void没有返回值，会返回undefined）
表达式前面加个void还可以使其不返回任何结果（俗称把返回值void掉~）

- undefined和null均不能够被封装，和number、string不一样

----------
### 0与-0
0 === -0； //true
> 需要-0的原因是有些应用程序中的数据需要数字的符号位来标识方向信息。所以产生了-0


----------
### 用于判断+0和-0还有NaN的方法
> ES6新增一个Object.is()方法来判断两个值是否相等

    Object.is( 2/'foo' , NaN);  //true
    Object.is( -3*0 , -0 );     //true

但是这个方法涉及判断较多，能直接用 == 或者 === 判断就直接判断比较好


----------
### 简单的标量基本类型值（字符串和数字等）通过值复制来赋值和传递。而复合值（对象）通过引用复制来赋值和传递


----------
### 原生函数
> 内部属性[[Class]] 这个内部属性存在所有typeof操作符返回object的对象里面。可以把它看做一个分类，这个属性可以通过Object.prototype.toString()来访问

---

>  封装对象
基本类型值并没有.length这些好用的属性，可以通过封装对象使它们拥有这些属性和方法- -JS会自动帮你封装对象....也可以自己封装（用new或者 Object() ）

> 封装对象的拆封
可用Object.valueOf()来取得基本类型的值


----------
### JS的稀疏数组

    var a = new Array(3);
    var b = [undefined, undefined, undefined];

    //
    a.map(function(v, i) { return i; });  
    b.map(function(v, i) { return i; });
    
    // [undefined, undefined, undefined]
    // [0, 1, 2] 
    
a数组正是因为JS中的稀疏数组的关系，存在了三个空单位，所以无法用map方法遍历输出下标

可以用：

    var a = Array.apply(null, { length: 3 } );

来创建无空单元的数组
> 永远不要创建和使用空单元的数组


----------
### symbol
> 符号可用于作为属性名

    var sym = Symbol('mySymbol');
    var obj = {};
    obj[sym] = 'symbol';

> 可用Object.getOwnPropertySymbols(obj)获得这个对象所有的symbol
常用于私有或特殊属性。

----------
### 原生对象prototype
> **Function.prototype是一个空函数
 Array.prototype是一个空数组
 RegExp是一个空的正则      
 这三个都是很好的默认值**
 
 - 但是如果这个默认值会被更改，就不要使用原型作为默认值。切记任何时候不能修改原型，这会造成严重的代码陷阱。


----------
## **强制类型转换**


    toString()。。。
> 基本类型值的字符串化规则是直接转为字符串
> 对象的字符串化规则是返回内部属性的[[Class]]的值（自定义除外）
数组有自己默认重新定义的toString()，返回数组每一项并用“，”拼接起来


----------
## 显示强制类型转换


----------


### ~（按位非）
> 按位非会将值强制类型转换为32位数字，然后执行字位操作

> 按位非大致等同于 ~x =  -（x+1）

- 所以 ~（-1） = 0 ... 这与indexOf() 配合起来使用很方便


----------
### 字位截取（~~）
> 两个 ~ 执行之后将于ToInt32() 的结果一样
可以截取掉小数部分，与Math.floor() 的结果差不多，但是对于负数的处理结果不一样


----------
### 字符串，解析与转换为数字类型
> 解析（parseInt()）
转换（Number()）
解析可以允许字符串有非数字，但是转换必须看整个整体的字符串，不允许出现非数字的字符


----------
### 显式转换Boolean
> Boolean() 和 ！


----------
## 隐式强制类型转换


----------
### 字符串和数字相加期间发生的事情
> “+”这个符号只要其中有一个字符串或者有一个能转换成字符串的东西（比如数组）就执行拼接。

> 我们常用 a + '' 来把a转化成字符串
但是如果a是一个对象的话，那JS内部会调用它的 valueOf() 方法
而String(a)调用的是a的 toString() 方法

- “+”操作符存在对象时，JS会尝试调用对象的valueOf()方法，如不能返回基本类型值，就调用toString()方法。然后化简出来之后有字符串就拼接，没有就+++


----------
### 布尔到数字
用 + 、+= 都可以将其化为数字


----------
### JS中的 || 和 &&
> JS中这两个操作符并不一定返回Boolean值，是返回两个操作数其中一个的值。

    a || b;
    // a ? a : b
    
    a && b;
    // a ? b : a
    
差不多可以这样理解

- 因此 ||  这个多用于设置默认值
- 而 && 会用于进行条件判断。如：a && foo() 。 可以检测当a为真时才调用foo( )

###另外ES6的Symbol有坑
> Symbol显式转换字符串可以但是用隐式会报错，不能转换为数字。

----------
### JS中的 == 和 === （=。=）

    var a = '42';
    var b = true;
    a == b     // ???
    
    // false

- 调用 == 时，有数字时字符串会化为数字，布尔值也会化为数字，true化为了1，所以false


----------
### JS中的 < 和 > 
> 如果比较的双方都是字符串，那将按字母顺序比较

> 先调用ToPrimitive()，如果出现非字符串，将会调用方法将双方转化为数值来进行比较。

- 需要注意的是

        var a = { b: 42 };
        var b = { b: 43 };
        
        a < b;
    
- JS中的 >= 和 <= 是 < 的取反和 > 的取反，也就是（不小于）和（不大于）的意思

### **应该注意使用比较符号时尽量用相同类型的值放在两边**


----------
## 语法（


----------
### 语句
> JS中每一个语句都有一个结果值，代码块{}的结果值是最后一个语句的结果值，但是这个结果值不能被赋给一个变量。暂时来说语句的结果值并没有什么卵用。

### 表达式的副作用
> a++ 和 ++a 就有返回的自增的先后之分，副作用则是a的自增。副作用就是表达式对变量进行的操作。


----------
### 标签语句
> 带标签的语句可以用标签作为一个锚点，break和continue可以使用这个标签进行跳转。（虽然并不建议使用标签=。=

> 好了，回到这个奇怪的问题（前面曾经提到

    {} + [];
    
    //'[object Object]'
    
    [] + {};
    
    //0
    
    
- 因为第一行这个 {} 出现在算术表达式里面，因此被当成一个空对象处理，toString返回的[object Object] 。。。第二行代码中 {} 出现在了前面，被当成是一个空代码块。什么都不执行，然后后面是一个 +[] , 所以[] 被化成了false，再 +false 转化成number就是0


----------
### 函数参数
> ES6开始可以为参数设置默认值，当你不传参或者传个undefined进去的时候，命名参数会自动赋为默认值。

    function foo(a = 42, b = a + 1) {
        console.log(
            arguments.length, a, b, arguments[0], arguments[1]
        );
    }
    
    foo();
    foo(10);
    foo(10, undefined);
    foo(10, null);      
    
    //可见arguments伪数组是依赖于我们传进去的参数的。
    
> 建立关联：arguments伪数组和参数对应。但是要与命名参数对应的话，要传参，因为传递参数之后，arguments数组中的对应单元才会和命名参数建立关联

    function foo(a) {
        a = 42;
        console.log(arguments[0]);
    }
    
    foo(2);
    foo();
    
> 若给上面的函数参数设默认值，则没有关联这个说法了（即并不会关联起来。arguments数组对应的是传进去的值，并不会被函数内部所改变

### 这是一种奇怪的机制
    